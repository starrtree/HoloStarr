<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HoloHand - Starr Tech Industries</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">

    <!-- Three.js & Loaders -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>

    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --holo-primary: #00f0ff;
            --holo-secondary: #004d52;
            --holo-bg: #000000;
            --holo-text: #e0faff;
            --holo-grid: rgba(0, 240, 255, 0.2);
            --font-display: 'Orbitron', sans-serif;
            --font-ui: 'Rajdhani', sans-serif;
        }

        * {
            box-sizing: border-box;
            user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--holo-bg);
            color: var(--holo-text);
            font-family: var(--font-ui);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: radial-gradient(circle at center, #0a1114 0%, #000000 100%);
        }

        /* --- INTRO SCREEN --- */
        #intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease-out;
        }

        .logo-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 50px;
        }

        .trapezoid-platform {
            width: 120px;
            height: 20px;
            background: rgba(0, 240, 255, 0.1);
            border: 2px solid var(--holo-primary);
            clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%);
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.4);
            position: relative;
        }

        .star-icon {
            font-size: 3rem;
            color: var(--holo-primary);
            margin-bottom: -15px;
            z-index: 2;
            animation: float 2s ease-in-out infinite;
            text-shadow: 0 0 15px var(--holo-primary);
        }

        @keyframes float {
            0%, 100% { transform: translateY(-5px); }
            50% { transform: translateY(-15px); }
        }

        .intro-title {
            font-family: var(--font-display);
            font-size: 3rem;
            letter-spacing: 4px;
            margin: 10px 0 5px 0;
            text-shadow: 0 0 20px var(--holo-primary);
            background: linear-gradient(to bottom, #fff, var(--holo-primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .intro-subtitle {
            font-family: var(--font-display);
            font-size: 0.9rem;
            letter-spacing: 2px;
            color: #888;
            text-transform: uppercase;
        }

        .input-wrapper {
            position: relative;
            width: 300px;
            border-bottom: 2px solid var(--holo-grid);
            transition: border-color 0.3s;
        }
        .input-wrapper:focus-within {
            border-bottom: 2px solid var(--holo-primary);
            box-shadow: 0 5px 10px -5px var(--holo-primary);
        }

        #intro-input {
            width: 100%;
            background: transparent;
            border: none;
            color: var(--holo-primary);
            font-family: var(--font-display);
            font-size: 1.5rem;
            text-align: center;
            text-transform: uppercase;
            outline: none;
            padding: 10px 0;
        }

        .loading-sequence {
            display: none;
            text-align: center;
        }

        .welcome-text {
            font-family: var(--font-display);
            font-size: 2rem;
            margin-bottom: 30px;
            color: var(--holo-primary);
            text-shadow: 0 0 15px var(--holo-primary);
        }

        /* --- HUD Overlay --- */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
        }

        .interactive { pointer-events: auto; }

        header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            text-shadow: 0 0 10px var(--holo-primary);
            border-bottom: 2px solid var(--holo-grid);
            padding-bottom: 10px;
        }

        .brand h1 {
            font-family: var(--font-display);
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: 2px;
            color: var(--holo-primary);
            text-transform: uppercase;
        }

        .brand h2 {
            margin: 0;
            font-size: 0.8rem;
            opacity: 0.7;
            letter-spacing: 4px;
        }

        .status-panel {
            text-align: right;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .status-item { margin-bottom: 4px; }
        .status-val { color: var(--holo-primary); font-weight: bold; }

        aside {
            position: absolute;
            top: 100px;
            right: 20px;
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel-box {
            background: rgba(0, 20, 30, 0.6);
            border: 1px solid var(--holo-grid);
            padding: 15px;
            backdrop-filter: blur(4px);
            position: relative;
        }

        .panel-box::before, .panel-box::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            border-color: var(--holo-primary);
            border-style: solid;
            transition: all 0.3s ease;
        }
        .panel-box::before { top: -1px; left: -1px; border-width: 2px 0 0 2px; }
        .panel-box::after { bottom: -1px; right: -1px; border-width: 0 2px 2px 0; }

        .user-info h3 {
            margin: 0 0 5px 0;
            color: var(--holo-primary);
            font-family: var(--font-display);
            font-size: 1rem;
        }

        #username-input {
            background: transparent;
            border: none;
            border-bottom: 1px dashed var(--holo-grid);
            color: var(--holo-primary);
            font-family: var(--font-display);
            font-size: 0.9rem;
            width: 100%;
            text-transform: uppercase;
            outline: none;
            padding: 2px 0;
            transition: border-color 0.3s;
        }
        #username-input:focus {
            border-bottom-color: var(--holo-primary);
            background: rgba(0, 240, 255, 0.1);
        }

        .color-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .btn {
            background: transparent;
            border: 1px solid var(--holo-primary);
            color: var(--holo-primary);
            font-family: var(--font-display);
            padding: 10px 20px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--holo-primary);
            color: #000;
            box-shadow: 0 0 15px var(--holo-primary);
        }

        .btn:active { transform: scale(0.98); }

        .btn-slim {
            padding: 4px 10px;
            font-size: 0.65rem;
            min-width: 50px;
        }

        .btn.active {
            background: var(--holo-primary);
            color: #000;
        }

        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 30px;
            height: 30px;
            background: none;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { 
            border: 1px solid var(--holo-primary); 
            border-radius: 50%; 
        }

        footer {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            border-top: 2px solid var(--holo-grid);
            padding-top: 10px;
        }

        .control-group { display: flex; gap: 15px; }

        #webcam-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 1px solid var(--holo-grid);
            opacity: 0.8;
            transform: scaleX(-1);
            display: none;
            background: #000;
        }
        #webcam-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .hand-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            font-family: var(--font-display);
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .hand-status {
            padding: 5px 10px;
            border: 1px solid var(--holo-primary);
            background: rgba(0,0,0,0.7);
            box-shadow: 0 0 10px var(--holo-primary);
        }

        #toast-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
            text-align: center;
        }
        .toast {
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid var(--holo-primary);
            color: var(--holo-primary);
            padding: 20px 40px;
            font-family: var(--font-display);
            font-size: 1.2rem;
            text-transform: uppercase;
            opacity: 0;
            transition: opacity 0.5s;
            box-shadow: 0 0 30px var(--holo-grid);
        }
        .toast.visible { opacity: 1; }

        .loader-ring {
            width: 60px; height: 60px;
            border: 4px solid var(--holo-secondary);
            border-top: 4px solid var(--holo-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #file-input { display: none; }
    </style>
</head>
<body>

    <!-- INTRO SCREEN -->
    <div id="intro-screen">
        <div class="logo-container" id="intro-logo">
            <div class="star-icon">âœ§</div>
            <div class="trapezoid-platform"></div>
            <div class="intro-title">HoloHand</div>
            <div class="intro-subtitle">by Starr Tech Industries</div>
        </div>

        <div class="input-wrapper" id="intro-input-wrapper">
            <input type="text" id="intro-input" placeholder="ENTER USER ID" maxlength="12" autocomplete="off" autofocus>
        </div>

        <div class="loading-sequence" id="loading-sequence">
            <div class="welcome-text">Welcome, <span id="welcome-name">User</span></div>
            <div class="loader-ring"></div>
        </div>
    </div>

    <!-- MAIN 3D INTERFACE -->
    <div id="canvas-container"></div>
    <video id="webcam-video" style="display:none;" playsinline></video>
    <div id="webcam-preview">
        <video id="webcam-mini" playsinline muted></video>
    </div>

    <div id="hud">
        <header>
            <div class="brand">
                <h1>HoloHand</h1>
                <h2>by Starr Tech Industries</h2>
            </div>
            <div class="status-panel">
                <div class="status-item">SYSTEM: <span class="status-val">ONLINE</span></div>
                <div class="status-item">FPS: <span id="fps-counter" class="status-val">00</span></div>
                <div class="status-item">MODE: <span id="mode-display" class="status-val">IDLE</span></div>
            </div>
        </header>

        <div class="hand-indicator" id="hand-feedback">
            <div class="hand-status" id="h1-status">L: NONE</div>
            <div class="hand-status" id="h2-status">R: NONE</div>
        </div>

        <aside>
            <div class="panel-box interactive">
                <div class="user-info">
                    <h3>USER ID:</h3>
                    <input type="text" id="username-input" value="T. STARK" maxlength="12">
                    <div style="font-size: 0.8rem; margin-bottom: 10px; margin-top: 5px;">PROJECT: <span id="project-name">DRONE_V5</span></div>
                </div>
                <hr style="border: 0; border-top: 1px solid var(--holo-grid); margin: 10px 0;">
                <div style="font-size: 0.8rem; text-transform: uppercase;">ElectriColor System</div>
                <div class="color-controls">
                    <button class="btn btn-slim" id="cycle-color-btn">Cycle</button>
                    <input type="color" id="color-picker" value="#00f0ff">
                </div>
            </div>
        </aside>

        <footer>
            <div class="control-group interactive">
                <!-- Idle Orbit Toggle (Visible only when Holo-Hand is OFF) -->
                <button class="btn" id="toggle-idle-orbit">
                    STOP ORBIT
                </button>
                
                <!-- Updated Input for multiple formats -->
                <input type="file" id="file-input" accept=".stl,.glb,.gltf,.obj">
                <button class="btn" onclick="document.getElementById('file-input').click()">
                    Upload Model
                </button>
                <button class="btn" id="reset-model-btn">
                    Reset Model
                </button>
            </div>
            
            <div class="control-group interactive">
                <!-- Fixed Initial Text: ENABLE -->
                <button class="btn" id="toggle-holo-hand">
                    ENABLE HOLO-HAND
                </button>
            </div>
        </footer>
    </div>

    <div id="toast-container">
        <div id="toast-msg" class="toast">Initializing Systems...</div>
    </div>

    <script>
        // --- INTRO LOGIC ---
        const introInput = document.getElementById('intro-input');
        const introWrapper = document.getElementById('intro-input-wrapper');
        const introLogo = document.getElementById('intro-logo');
        const loadingSeq = document.getElementById('loading-sequence');
        const welcomeName = document.getElementById('welcome-name');
        const introScreen = document.getElementById('intro-screen');
        const mainUsername = document.getElementById('username-input');

        introInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && this.value.trim().length > 0) {
                startIntro(this.value.trim());
            }
        });

        function startIntro(name) {
            introWrapper.style.display = 'none';
            introLogo.style.opacity = '0';
            setTimeout(() => { introLogo.style.display = 'none'; }, 500);
            loadingSeq.style.display = 'block';
            welcomeName.innerText = name.toUpperCase();
            mainUsername.value = name.toUpperCase();

            setTimeout(() => {
                introScreen.style.opacity = '0';
                setTimeout(() => {
                    introScreen.style.display = 'none';
                    if (!animationStarted) {
                        animationStarted = true;
                        animate(0);
                    }
                }, 1000);
            }, 2500);
        }

        // --- CORE LOGIC ---
        const config = {
            colors: ['#00f0ff', '#ff0055', '#00ff66', '#ffee00', '#ffffff'],
            currentColorIdx: 0,
            holoEnabled: false,
            idleOrbitEnabled: true, 
            pinchThreshold: 0.08,
            closedThreshold: 0.1,
            lerpFactor: 0.15,
            rotationLerp: 0.2,
            scaleLerp: 0.1,
            scaleUpSensitivity: 3.0,
            scaleDownSensitivity: 8.0 
        };

        const state = {
            mode: 'IDLE',
            hands: [],
            activeHandIndex: -1,
            masterHandIndex: -1,
            targetScale: 1,
            targetPosition: new THREE.Vector3(0, 5, 0),
            targetRotation: new THREE.Euler(0, 0, 0),
            lastPinchDist: 0,
            handStartPos: { x: 0, y: 0 },
            initialTrans: new THREE.Vector3(),
            initialRot: new THREE.Euler(),
            initialLoadedScale: 1, 
            desiredMode: 'IDLE',
            modeStability: 0,
            stabilityThreshold: 5
        };

        const ui = {
            fps: document.getElementById('fps-counter'),
            mode: document.getElementById('mode-display'),
            project: document.getElementById('project-name'),
            handFeedback: document.getElementById('hand-feedback'),
            h1Status: document.getElementById('h1-status'),
            h2Status: document.getElementById('h2-status'),
            toast: document.getElementById('toast-msg'),
            colorPicker: document.getElementById('color-picker'),
            cycleBtn: document.getElementById('cycle-color-btn'),
            toggleHandBtn: document.getElementById('toggle-holo-hand'),
            camPreview: document.getElementById('webcam-preview'),
            camMini: document.getElementById('webcam-mini'),
            resetBtn: document.getElementById('reset-model-btn'),
            idleOrbitBtn: document.getElementById('toggle-idle-orbit')
        };

        const lerp = (start, end, amt) => (1 - amt) * start + amt * end;
        const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

        function showToast(msg, duration = 2000) {
            ui.toast.innerText = msg;
            ui.toast.classList.add('visible');
            if (duration > 0) setTimeout(() => ui.toast.classList.remove('visible'), duration);
        }

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 30);
        camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = true;
        controls.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN
        };

        const gridHelper = new THREE.GridHelper(60, 60, config.colors[0], 0x112233);
        scene.add(gridHelper);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        const modelGroup = new THREE.Group();
        scene.add(modelGroup);
        modelGroup.position.set(0, 5, 0);
        modelGroup.scale.set(1, 1, 1);

        function syncTargets() {
            state.targetPosition.copy(modelGroup.position);
            state.targetRotation.copy(modelGroup.rotation);
            state.targetScale = modelGroup.scale.x;
        }
        syncTargets();

        let holoMesh = null, solidMesh = null;
        let animationStarted = false; 

        // --- Model Loading & Hologram Effect ---

        // Helper: Apply hologram effect to a mesh
        function hologramifyMesh(mesh, colorHex) {
            const color = new THREE.Color(colorHex);
            
            // 1. Handle the solid part (Texture aware)
            // If material has a map, we keep it but tint it
            if (mesh.material.map) {
                // Keep existing material settings but adjust for Holo look
                mesh.material.transparent = true;
                mesh.material.opacity = 0.7; // Semi-transparent
                mesh.material.color = color; // Tint with holo color
                mesh.material.side = THREE.DoubleSide;
                mesh.material.depthWrite = true;
            } else {
                // Standard geometry without texture
                mesh.material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
            }

            // 2. Add Wireframe/Edge Overlay
            // Use EdgesGeometry for cleaner lines than WireframeGeometry
            const edges = new THREE.EdgesGeometry(mesh.geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.6 
            }));
            
            // Add the line as a child of the mesh so it moves/rotates with it
            mesh.add(line);
            
            // Store reference for color cycling
            mesh.userData.isHolo = true;
            mesh.userData.holoLine = line;
        }

        // Helper: Traverse and Apply
        function processModelMeshes(object, colorHex) {
            object.traverse((child) => {
                if (child.isMesh) {
                    hologramifyMesh(child, colorHex);
                }
            });
        }

        function createDronePlaceholder() {
            const geo = new THREE.BoxGeometry(4, 1, 4);
            const wingGeo = new THREE.BoxGeometry(10, 0.2, 1);
            
            // Manually create mesh structure for placeholder
            const bodyMesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: config.colors[0], transparent: true, opacity: 0.1 }));
            const wingsMesh = new THREE.Mesh(wingGeo, new THREE.MeshBasicMaterial({ color: config.colors[0], transparent: true, opacity: 0.1 }));
            wingsMesh.position.y = 0.5;
            
            modelGroup.add(bodyMesh);
            modelGroup.add(wingsMesh);

            // Apply holo effect
            hologramifyMesh(bodyMesh, config.colors[0]);
            hologramifyMesh(wingsMesh, config.colors[0]);

            holoMesh = bodyMesh; // Ref for opacity flicker
            state.initialLoadedScale = 1.0;
            syncTargets();
        }
        createDronePlaceholder();

        // --- Loaders ---
        const loaderStl = new THREE.STLLoader();
        const loaderGltf = new THREE.GLTFLoader();
        const loaderObj = new THREE.OBJLoader();

        // --- File Input Handler ---
        document.getElementById('file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const ext = file.name.split('.').pop().toLowerCase();
            ui.project.innerText = file.name.split('.')[0].toUpperCase();
            showToast("PARSING BLUEPRINT DATA...", 0);

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    // 1. Clear Previous
                    while(modelGroup.children.length > 0){ modelGroup.remove(modelGroup.children[0]); }
                    
                    let loadedObject = null;

                    // 2. Load based on extension
                    if (ext === 'stl') {
                        const geometry = loaderStl.parse(event.target.result);
                        const mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial()); // Material will be overwritten
                        loadedObject = mesh;
                    } 
                    else if (ext === 'gltf' || ext === 'glb') {
                        const gltf = loaderGltf.parse(event.target.result);
                        loadedObject = gltf.scene;
                    } 
                    else if (ext === 'obj') {
                        loadedObject = loaderObj.parse(event.target.result);
                    }
                    else {
                        throw new Error("Unsupported Format");
                    }

                    // 3. Normalize & Center
                    const box = new THREE.Box3().setFromObject(loadedObject);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 10 / maxDim; // Target size ~10 units
                    
                    state.initialLoadedScale = scale;

                    // 4. Apply Transforms
                    // For GLTF/OBJ, we move the group to center. For STL, we center the geo.
                    if (ext === 'stl') {
                        loadedObject.geometry.center();
                    } else {
                        loadedObject.position.sub(center);
                    }
                    
                    modelGroup.add(loadedObject);
                    
                    modelGroup.scale.set(scale, scale, scale);
                    modelGroup.position.set(0, 5, 0); // Center on platform
                    modelGroup.rotation.set(0, 0, 0);

                    // 5. Apply Hologram Effects to all meshes
                    processModelMeshes(loadedObject, config.colors[0]);
                    
                    // 6. Set Flicker Reference (first mesh found)
                    let found = false;
                    loadedObject.traverse(c => {
                        if (c.isMesh && !found) {
                            holoMesh = c;
                            found = true;
                        }
                    });

                    syncTargets();
                    showToast(`LOADED ${ext.toUpperCase()}`);

                } catch (err) {
                    console.error(err);
                    showToast("ERROR: FILE PARSING FAILED");
                }
            };

            // GLB is binary, others text
            if (ext === 'glb') {
                reader.readAsArrayBuffer(file);
            } else {
                reader.readAsText(file);
            }
        });

        ui.idleOrbitBtn.addEventListener('click', () => {
            config.idleOrbitEnabled = !config.idleOrbitEnabled;
            if (config.idleOrbitEnabled) {
                ui.idleOrbitBtn.innerText = "STOP ORBIT";
                ui.idleOrbitBtn.classList.remove('active');
                showToast("ORBITATION ENABLED", 1000);
            } else {
                ui.idleOrbitBtn.innerText = "START ORBIT";
                ui.idleOrbitBtn.classList.add('active');
                showToast("ORBITATION DISABLED", 1000);
            }
        });

        ui.resetBtn.addEventListener('click', () => {
            const s = state.initialLoadedScale;
            modelGroup.position.set(0, 5, 0);
            modelGroup.rotation.set(0, 0, 0);
            modelGroup.scale.set(s, s, s);
            syncTargets();
            showToast("MODEL RESET TO INITIAL CONFIG");
        });

        function updateThemeColor(hexColor) {
            document.documentElement.style.setProperty('--holo-primary', hexColor);
            const color = new THREE.Color(hexColor);
            gridHelper.material.color = color;
            ambientLight.color.set(color);
            dirLight.color.set(color);

            // Update all hologram meshes
            modelGroup.traverse((child) => {
                if (child.isMesh && child.userData.isHolo) {
                    // Update wireframe color
                    if (child.userData.holoLine) {
                        child.userData.holoLine.material.color.set(color);
                    }
                    // Update mesh tint (if it has a map, we tint the color property)
                    if (child.material) {
                        child.material.color.set(color);
                    }
                }
            });
        }
        ui.cycleBtn.addEventListener('click', () => {
            config.currentColorIdx = (config.currentColorIdx + 1) % config.colors.length;
            const color = config.colors[config.currentColorIdx];
            updateThemeColor(color);
            ui.colorPicker.value = color;
        });
        ui.colorPicker.addEventListener('input', (e) => updateThemeColor(e.target.value));

        // --- MediaPipe Setup ---
        const videoElement = document.getElementById('webcam-video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onHandsResults);
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });

        ui.toggleHandBtn.addEventListener('click', () => {
            config.holoEnabled = !config.holoEnabled;
            if (config.holoEnabled) {
                ui.toggleHandBtn.innerText = "DISABLE HOLO-HAND";
                ui.toggleHandBtn.classList.add('active');
                ui.camPreview.style.display = "block";
                ui.camMini.srcObject = videoElement.srcObject;
                ui.idleOrbitBtn.style.display = "none";
                showToast("INITIALIZING NEURAL LINK...");
                cameraUtils.start();
            } else {
                ui.toggleHandBtn.innerText = "ENABLE HOLO-HAND";
                ui.toggleHandBtn.classList.remove('active');
                ui.camPreview.style.display = "none";
                state.desiredMode = 'IDLE';
                state.modeStability = 0;
                updateHandUI(null, null);
                ui.idleOrbitBtn.style.display = "inline-flex";
                showToast("NEURAL LINK TERMINATED");
                const stream = videoElement.srcObject;
                if (stream) stream.getTracks().forEach(track => track.stop());
            }
        });

        function detectGesture(landmarks) {
            const thumb = landmarks[4], index = landmarks[8];
            const mid = landmarks[12], ring = landmarks[16], pinky = landmarks[20];
            const indexPip = landmarks[6], midPip = landmarks[10], ringPip = landmarks[14], pinkyPip = landmarks[18];

            const distPinch = Math.hypot(thumb.x - index.x, thumb.y - index.y);
            const isPinch = distPinch < config.pinchThreshold;

            let curled = 0;
            if (index.y > indexPip.y) curled++;
            if (mid.y > midPip.y) curled++;
            if (ring.y > ringPip.y) curled++;
            if (pinky.y > pinkyPip.y) curled++;

            const isClosed = curled >= 3 && !isPinch;
            const isOpen = !isPinch && !isClosed;
            return { isPinch, isClosed, isOpen, center: index };
        }

        function getHandDistance(p1, p2) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y);
        }

        function onHandsResults(results) {
            state.hands = [];
            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const lm = results.multiHandLandmarks[i];
                    const label = results.multiHandedness[i].label;
                    state.hands.push({ label, gesture: detectGesture(lm), center: lm[8] });
                }
            }
            processInteraction();
            updateHandUI(state.hands[0], state.hands[1]);
        }

        function processInteraction() {
            const h1 = state.hands[0];
            const h2 = state.hands[1];
            let desired = 'IDLE';
            if (h1 && h2) {
                if (h1.gesture.isPinch && h2.gesture.isPinch) desired = 'SCALING';
                else if (h1.gesture.isClosed && h2.gesture.isClosed) desired = 'TRANSLATING';
                else if (h1.gesture.isPinch && h2.gesture.isOpen) desired = 'ROTATING';
                else if (h2.gesture.isPinch && h1.gesture.isOpen) desired = 'ROTATING';
                else desired = 'IDLE';
            } else if (h1) {
                if (h1.gesture.isPinch) desired = 'ROTATING';
                else if (h1.gesture.isClosed) desired = 'TRANSLATING';
                else desired = 'IDLE';
            }

            if (desired === state.mode) {
                state.modeStability = 0;
            } else {
                state.modeStability++;
                if (state.modeStability > state.stabilityThreshold) {
                    state.mode = desired;
                    state.modeStability = 0;
                    initInteractionState(h1, h2);
                }
            }

            if (state.mode === 'SCALING' && h1 && h2) {
                const currentDist = getHandDistance(h1.gesture.center, h2.gesture.center);
                if (state.lastPinchDist > 0) {
                    const delta = currentDist - state.lastPinchDist;
                    let sensitivity = config.scaleUpSensitivity;
                    if (delta < 0) sensitivity = config.scaleDownSensitivity;
                    state.targetScale *= (1 + delta * sensitivity);
                    state.targetScale = clamp(state.targetScale, 0.05, 20); 
                }
                state.lastPinchDist = currentDist;
                ui.mode.innerText = "SCALING";
            } 
            else if (state.mode === 'TRANSLATING') {
                let master = h1;
                if (h1 && h2 && h1.gesture.isClosed && h2.gesture.isClosed) {
                    master = state.masterHandIndex === 0 ? h1 : h2;
                }
                if (master) {
                    const dx = (master.gesture.center.x - state.handStartPos.x) * 50;
                    const dy = -(master.gesture.center.y - state.handStartPos.y) * 50;
                    state.targetPosition.x = state.initialTrans.x + dx;
                    state.targetPosition.y = state.initialTrans.y + dy;
                }
                ui.mode.innerText = "TRANSLATING";
            } 
            else if (state.mode === 'ROTATING') {
                let active = h1;
                if (h1 && h2) active = h1.gesture.isPinch ? h1 : h2;
                if (active) {
                    const dx = (active.gesture.center.x - state.handStartPos.x) * 5;
                    const dy = (active.gesture.center.y - state.handStartPos.y) * 5;
                    state.targetRotation.y = state.initialRot.y + dx;
                    state.targetRotation.x = state.initialRot.x + dy;
                }
                ui.mode.innerText = "ROTATING";
            } 
            else {
                state.lastPinchDist = 0;
                ui.mode.innerText = "IDLE";
            }
        }

        function initInteractionState(h1, h2) {
            syncTargets();
            state.initialTrans.copy(modelGroup.position);
            state.initialRot.copy(modelGroup.rotation);

            if (state.mode === 'SCALING') {
                if (h1 && h2) {
                    state.lastPinchDist = getHandDistance(h1.gesture.center, h2.gesture.center);
                }
            } 
            else if (state.mode === 'ROTATING') {
                const active = h1 && h2 ? (h1.gesture.isPinch ? h1 : h2) : h1;
                if (active) {
                    state.handStartPos = { x: active.gesture.center.x, y: active.gesture.center.y };
                }
            } 
            else if (state.mode === 'TRANSLATING') {
                if (h1 && h2 && h1.gesture.isClosed && h2.gesture.isClosed) {
                    if (state.masterHandIndex === -1) state.masterHandIndex = 0;
                    const master = state.masterHandIndex === 0 ? h1 : h2;
                    state.handStartPos = { x: master.gesture.center.x, y: master.gesture.center.y };
                } else if (h1) {
                    state.handStartPos = { x: h1.gesture.center.x, y: h1.gesture.center.y };
                    state.masterHandIndex = -1;
                }
            }
        }

        function updateHandUI(h1, h2) {
            ui.handFeedback.style.opacity = (h1 || h2) ? 1 : 0;
            if (h1) {
                let status = "OPEN";
                if (h1.gesture.isPinch) status = "PINCH";
                else if (h1.gesture.isClosed) status = "CLOSED";
                ui.h1Status.innerText = `${h1.label}: ${status}`;
                ui.h1Status.style.opacity = 1;
            } else { ui.h1Status.style.opacity = 0.1; }
            
            if (h2) {
                let status = "OPEN";
                if (h2.gesture.isPinch) status = "PINCH";
                else if (h2.gesture.isClosed) status = "CLOSED";
                ui.h2Status.innerText = `${h2.label}: ${status}`;
                ui.h2Status.style.opacity = 1;
            } else { ui.h2Status.style.opacity = 0.1; }
        }

        // --- Animation Loop ---
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            const delta = (time - lastTime) / 1000;
            lastTime = time;

            if (delta > 0) {
                const fps = Math.round(1 / delta);
                if (Math.random() > 0.9) ui.fps.innerText = fps;
            }

            modelGroup.position.lerp(state.targetPosition, config.lerpFactor);
            modelGroup.rotation.x = lerp(modelGroup.rotation.x, state.targetRotation.x, config.rotationLerp);
            modelGroup.rotation.y = lerp(modelGroup.rotation.y, state.targetRotation.y, config.rotationLerp);
            
            const scaleVal = lerp(modelGroup.scale.x, state.targetScale, config.scaleLerp);
            modelGroup.scale.set(scaleVal, scaleVal, scaleVal);

            if (state.mode === 'IDLE' && !config.holoEnabled && config.idleOrbitEnabled) {
                modelGroup.rotation.y += 0.002;
                modelGroup.position.y = 5 + Math.sin(time * 0.001) * 0.2;
                state.targetPosition.y = modelGroup.position.y;
                state.targetRotation.y = modelGroup.rotation.y;
            }

            // Flicker effect on wireframes
            if (holoMesh && Math.random() > 0.92) {
                const base = 0.6;
                holoMesh.userData.holoLine.material.opacity = base + (Math.random() * 0.2 - 0.1);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>