<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HoloView - Starr Tech Industries</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">

    <!-- Three.js & Loaders -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>

    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --holo-primary: #00f0ff;
            --holo-secondary: #004d52;
            --holo-bg: #000000;
            --holo-text: #e0faff;
            --holo-grid: rgba(0, 240, 255, 0.2);
            --font-display: 'Orbitron', sans-serif;
            --font-ui: 'Rajdhani', sans-serif;
        }

        * {
            box-sizing: border-box;
            user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--holo-bg);
            color: var(--holo-text);
            font-family: var(--font-ui);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: radial-gradient(circle at center, #0a1114 0%, #000000 100%);
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
        }

        .interactive { pointer-events: auto; }

        header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            text-shadow: 0 0 10px var(--holo-primary);
            border-bottom: 2px solid var(--holo-grid);
            padding-bottom: 10px;
        }

        .brand h1 {
            font-family: var(--font-display);
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: 2px;
            color: var(--holo-primary);
            text-transform: uppercase;
        }

        .brand h2 {
            margin: 0;
            font-size: 0.8rem;
            opacity: 0.7;
            letter-spacing: 4px;
        }

        .status-panel {
            text-align: right;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .status-item { margin-bottom: 4px; }
        .status-val { color: var(--holo-primary); font-weight: bold; }

        aside {
            position: absolute;
            top: 100px;
            right: 20px;
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel-box {
            background: rgba(0, 20, 30, 0.6);
            border: 1px solid var(--holo-grid);
            padding: 15px;
            backdrop-filter: blur(4px);
            position: relative;
        }

        .panel-box::before, .panel-box::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            border-color: var(--holo-primary);
            border-style: solid;
            transition: all 0.3s ease;
        }
        .panel-box::before { top: -1px; left: -1px; border-width: 2px 0 0 2px; }
        .panel-box::after { bottom: -1px; right: -1px; border-width: 0 2px 2px 0; }

        .user-info h3 {
            margin: 0 0 5px 0;
            color: var(--holo-primary);
            font-family: var(--font-display);
            font-size: 1rem;
        }

        #username-input {
            background: transparent;
            border: none;
            border-bottom: 1px dashed var(--holo-grid);
            color: var(--holo-primary);
            font-family: var(--font-display);
            font-size: 0.9rem;
            width: 100%;
            text-transform: uppercase;
            outline: none;
            padding: 2px 0;
            transition: border-color 0.3s;
        }
        #username-input:focus {
            border-bottom-color: var(--holo-primary);
            background: rgba(0, 240, 255, 0.1);
        }

        .color-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .btn {
            background: transparent;
            border: 1px solid var(--holo-primary);
            color: var(--holo-primary);
            font-family: var(--font-display);
            padding: 10px 20px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--holo-primary);
            color: #000;
            box-shadow: 0 0 15px var(--holo-primary);
        }

        .btn:active { transform: scale(0.98); }

        .btn-slim {
            padding: 4px 10px;
            font-size: 0.65rem;
            min-width: 50px;
        }

        /* Active state for buttons */
        .btn.active {
            background: var(--holo-primary);
            color: #000;
        }

        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 30px;
            height: 30px;
            background: none;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { 
            border: 1px solid var(--holo-primary); 
            border-radius: 50%; 
        }

        footer {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            border-top: 2px solid var(--holo-grid);
            padding-top: 10px;
        }

        .control-group { display: flex; gap: 15px; }

        #webcam-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 1px solid var(--holo-grid);
            opacity: 0.8;
            transform: scaleX(-1);
            display: none;
            background: #000;
        }
        #webcam-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .hand-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            font-family: var(--font-display);
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .hand-status {
            padding: 5px 10px;
            border: 1px solid var(--holo-primary);
            background: rgba(0,0,0,0.7);
            box-shadow: 0 0 10px var(--holo-primary);
        }

        #toast-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
            text-align: center;
        }
        .toast {
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid var(--holo-primary);
            color: var(--holo-primary);
            padding: 20px 40px;
            font-family: var(--font-display);
            font-size: 1.2rem;
            text-transform: uppercase;
            opacity: 0;
            transition: opacity 0.5s;
            box-shadow: 0 0 30px var(--holo-grid);
        }
        .toast.visible { opacity: 1; }

        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.8s;
        }
        .loader-ring {
            width: 60px; height: 60px;
            border: 4px solid var(--holo-secondary);
            border-top: 4px solid var(--holo-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #file-input { display: none; }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <video id="webcam-video" style="display:none;" playsinline></video>
    <div id="webcam-preview">
        <video id="webcam-mini" playsinline muted></video>
    </div>

    <div id="hud">
        <header>
            <div class="brand">
                <h1>Starr Tech Industries</h1>
                <h2>Engineering Hologram Platform vS.8</h2>
            </div>
            <div class="status-panel">
                <div class="status-item">SYSTEM: <span class="status-val">ONLINE</span></div>
                <div class="status-item">FPS: <span id="fps-counter" class="status-val">00</span></div>
                <div class="status-item">MODE: <span id="mode-display" class="status-val">IDLE</span></div>
            </div>
        </header>

        <div class="hand-indicator" id="hand-feedback">
            <div class="hand-status" id="h1-status">L: NONE</div>
            <div class="hand-status" id="h2-status">R: NONE</div>
        </div>

        <aside>
            <div class="panel-box interactive">
                <div class="user-info">
                    <h3>USER ID:</h3>
                    <input type="text" id="username-input" value="T. STARK" maxlength="12">
                    <div style="font-size: 0.8rem; margin-bottom: 10px; margin-top: 5px;">PROJECT: <span id="project-name">DRONE_V5</span></div>
                </div>
                <hr style="border: 0; border-top: 1px solid var(--holo-grid); margin: 10px 0;">
                <div style="font-size: 0.8rem; text-transform: uppercase;">ElectriColor System</div>
                <div class="color-controls">
                    <button class="btn btn-slim" id="cycle-color-btn">Cycle</button>
                    <input type="color" id="color-picker" value="#00f0ff">
                </div>
            </div>
        </aside>

        <footer>
            <div class="control-group interactive">
                <!-- Idle Orbit Toggle (Visible only when Holo-Hand is OFF) -->
                <button class="btn" id="toggle-idle-orbit">
                    STOP ORBIT
                </button>
                
                <input type="file" id="file-input" accept=".stl">
                <button class="btn" onclick="document.getElementById('file-input').click()">
                    Upload Model (.STL)
                </button>
                <button class="btn" id="reset-model-btn">
                    Reset Model
                </button>
            </div>
            
            <div class="control-group interactive">
                <!-- Fixed Initial Text: ENABLE -->
                <button class="btn" id="toggle-holo-hand">
                    ENABLE HOLO-HAND
                </button>
            </div>
        </footer>
    </div>

    <div id="toast-container">
        <div id="toast-msg" class="toast">Initializing Systems...</div>
    </div>

    <div id="loader">
        <div class="loader-ring"></div>
        <div style="margin-top: 20px; font-family: var(--font-display); color: var(--holo-primary);">LOADING CORE MODULES</div>
    </div>

    <script>
        const config = {
            colors: ['#00f0ff', '#ff0055', '#00ff66', '#ffee00', '#ffffff'],
            currentColorIdx: 0,
            holoEnabled: false,
            idleOrbitEnabled: true, // Controls the auto-orbit when hands are off
            pinchThreshold: 0.08,
            closedThreshold: 0.1,
            lerpFactor: 0.15,
            rotationLerp: 0.2,
            scaleLerp: 0.1,
            // Asymmetric scaling sensitivities
            scaleUpSensitivity: 3.0,
            scaleDownSensitivity: 8.0 
        };

        const state = {
            mode: 'IDLE',
            hands: [],
            activeHandIndex: -1,
            masterHandIndex: -1,
            
            targetScale: 1,
            targetPosition: new THREE.Vector3(0, 5, 0),
            targetRotation: new THREE.Euler(0, 0, 0),
            
            lastPinchDist: 0,
            handStartPos: { x: 0, y: 0 },
            initialTrans: new THREE.Vector3(),
            initialRot: new THREE.Euler(),
            
            // Stores the perfect scale calculated on upload
            initialLoadedScale: 1, 
            
            desiredMode: 'IDLE',
            modeStability: 0,
            stabilityThreshold: 5
        };

        const ui = {
            fps: document.getElementById('fps-counter'),
            mode: document.getElementById('mode-display'),
            project: document.getElementById('project-name'),
            handFeedback: document.getElementById('hand-feedback'),
            h1Status: document.getElementById('h1-status'),
            h2Status: document.getElementById('h2-status'),
            toast: document.getElementById('toast-msg'),
            loader: document.getElementById('loader'),
            colorPicker: document.getElementById('color-picker'),
            cycleBtn: document.getElementById('cycle-color-btn'),
            toggleHandBtn: document.getElementById('toggle-holo-hand'),
            camPreview: document.getElementById('webcam-preview'),
            camMini: document.getElementById('webcam-mini'),
            resetBtn: document.getElementById('reset-model-btn'),
            idleOrbitBtn: document.getElementById('toggle-idle-orbit')
        };

        // --- Utils ---
        const lerp = (start, end, amt) => (1 - amt) * start + amt * end;
        const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

        function showToast(msg, duration = 2000) {
            ui.toast.innerText = msg;
            ui.toast.classList.add('visible');
            if (duration > 0) setTimeout(() => ui.toast.classList.remove('visible'), duration);
        }

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 30);
        camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = true;
        controls.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN
        };

        const gridHelper = new THREE.GridHelper(60, 60, config.colors[0], 0x112233);
        scene.add(gridHelper);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        const modelGroup = new THREE.Group();
        scene.add(modelGroup);
        modelGroup.position.set(0, 5, 0);
        modelGroup.scale.set(1, 1, 1);

        function syncTargets() {
            state.targetPosition.copy(modelGroup.position);
            state.targetRotation.copy(modelGroup.rotation);
            state.targetScale = modelGroup.scale.x;
        }
        syncTargets();

        let holoMesh = null, solidMesh = null;

        function createDronePlaceholder() {
            const geo = new THREE.BoxGeometry(4, 1, 4);
            const wingGeo = new THREE.BoxGeometry(10, 0.2, 1);
            const matParams = { color: config.colors[0], wireframe: true, transparent: true, opacity: 0.5 };
            const solidParams = { color: config.colors[0], transparent: true, opacity: 0.1, side: THREE.DoubleSide };
            const bodyWire = new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial(matParams));
            const bodySolid = new THREE.Mesh(geo, new THREE.MeshBasicMaterial(solidParams));
            const wingsWire = new THREE.LineSegments(new THREE.EdgesGeometry(wingGeo), new THREE.LineBasicMaterial(matParams));
            const wingsSolid = new THREE.Mesh(wingGeo, new THREE.MeshBasicMaterial(solidParams));
            wingsSolid.position.y = 0.5;
            modelGroup.add(bodyWire, bodySolid, wingsWire, wingsSolid);
            holoMesh = bodyWire;
            state.initialLoadedScale = 1.0;
            syncTargets();
        }
        createDronePlaceholder();

        // --- Idle Orbit Toggle Logic ---
        ui.idleOrbitBtn.addEventListener('click', () => {
            config.idleOrbitEnabled = !config.idleOrbitEnabled;
            
            if (config.idleOrbitEnabled) {
                ui.idleOrbitBtn.innerText = "STOP ORBIT";
                ui.idleOrbitBtn.classList.remove('active'); // Remove active styling
                showToast("ORBITATION ENABLED", 1000);
            } else {
                ui.idleOrbitBtn.innerText = "START ORBIT";
                ui.idleOrbitBtn.classList.add('active'); // Add active styling (Cyan bg)
                showToast("ORBITATION DISABLED", 1000);
            }
        });

        // --- Reset Logic ---
        ui.resetBtn.addEventListener('click', () => {
            const s = state.initialLoadedScale;
            modelGroup.position.set(0, 5, 0);
            modelGroup.rotation.set(0, 0, 0);
            modelGroup.scale.set(s, s, s);
            syncTargets();
            showToast("MODEL RESET TO INITIAL CONFIG");
        });

        // --- Model Loading ---
        document.getElementById('file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            ui.project.innerText = file.name.split('.')[0].toUpperCase();
            showToast("PARSING BLUEPRINT DATA...", 0);
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const loader = new THREE.STLLoader();
                    const geometry = loader.parse(event.target.result);
                    while(modelGroup.children.length > 0){ modelGroup.remove(modelGroup.children[0]); }
                    geometry.center();
                    const size = new THREE.Vector3();
                    geometry.boundingBox.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 10 / maxDim;
                    state.initialLoadedScale = scale;

                    const materialWire = new THREE.LineBasicMaterial({ color: config.colors[0], transparent: true, opacity: 0.6 });
                    const materialSolid = new THREE.MeshBasicMaterial({ color: config.colors[0], transparent: true, opacity: 0.1, side: THREE.DoubleSide });
                    const edges = new THREE.EdgesGeometry(geometry);
                    holoMesh = new THREE.LineSegments(edges, materialWire);
                    solidMesh = new THREE.Mesh(geometry, materialSolid);
                    modelGroup.add(holoMesh, solidMesh);
                    
                    modelGroup.scale.set(scale, scale, scale);
                    modelGroup.position.set(0, 5, 0);
                    modelGroup.rotation.set(0, 0, 0);
                    
                    syncTargets();
                    showToast("MODEL UPLOADED & SCALED");
                } catch (err) {
                    showToast("ERROR: INVALID STL FILE");
                }
            };
            reader.readAsArrayBuffer(file);
        });

        // --- Color System ---
        function updateThemeColor(hexColor) {
            document.documentElement.style.setProperty('--holo-primary', hexColor);
            const color = new THREE.Color(hexColor);
            gridHelper.material.color = color;
            if (holoMesh) holoMesh.material.color.set(color);
            if (solidMesh) solidMesh.material.color.set(color);
            ambientLight.color.set(color);
            dirLight.color.set(color);
        }
        ui.cycleBtn.addEventListener('click', () => {
            config.currentColorIdx = (config.currentColorIdx + 1) % config.colors.length;
            const color = config.colors[config.currentColorIdx];
            updateThemeColor(color);
            ui.colorPicker.value = color;
        });
        ui.colorPicker.addEventListener('input', (e) => updateThemeColor(e.target.value));

        // --- MediaPipe Setup ---
        const videoElement = document.getElementById('webcam-video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onHandsResults);
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });

        ui.toggleHandBtn.addEventListener('click', () => {
            config.holoEnabled = !config.holoEnabled;
            
            if (config.holoEnabled) {
                // Turn ON Holo-Hand
                ui.toggleHandBtn.innerText = "DISABLE HOLO-HAND";
                ui.toggleHandBtn.classList.add('active'); // Adds background color
                ui.camPreview.style.display = "block";
                ui.camMini.srcObject = videoElement.srcObject;
                
                // Hide Idle Orbit Button because hands take over
                ui.idleOrbitBtn.style.display = "none";
                
                showToast("INITIALIZING NEURAL LINK...");
                cameraUtils.start();
            } else {
                // Turn OFF Holo-Hand
                ui.toggleHandBtn.innerText = "ENABLE HOLO-HAND";
                ui.toggleHandBtn.classList.remove('active'); // Removes background color
                ui.camPreview.style.display = "none";
                state.desiredMode = 'IDLE';
                state.modeStability = 0;
                updateHandUI(null, null);
                
                // Show Idle Orbit Button again
                ui.idleOrbitBtn.style.display = "inline-flex";
                
                showToast("NEURAL LINK TERMINATED");
                const stream = videoElement.srcObject;
                if (stream) stream.getTracks().forEach(track => track.stop());
            }
        });

        // --- Gesture Logic ---
        function detectGesture(landmarks) {
            const thumb = landmarks[4], index = landmarks[8];
            const mid = landmarks[12], ring = landmarks[16], pinky = landmarks[20];
            const indexPip = landmarks[6], midPip = landmarks[10], ringPip = landmarks[14], pinkyPip = landmarks[18];

            const distPinch = Math.hypot(thumb.x - index.x, thumb.y - index.y);
            const isPinch = distPinch < config.pinchThreshold;

            let curled = 0;
            if (index.y > indexPip.y) curled++;
            if (mid.y > midPip.y) curled++;
            if (ring.y > ringPip.y) curled++;
            if (pinky.y > pinkyPip.y) curled++;

            const isClosed = curled >= 3 && !isPinch;
            const isOpen = !isPinch && !isClosed;
            return { isPinch, isClosed, isOpen, center: index };
        }

        function getHandDistance(p1, p2) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y);
        }

        function onHandsResults(results) {
            state.hands = [];
            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const lm = results.multiHandLandmarks[i];
                    const label = results.multiHandedness[i].label;
                    state.hands.push({ label, gesture: detectGesture(lm), center: lm[8] });
                }
            }
            processInteraction();
            updateHandUI(state.hands[0], state.hands[1]);
        }

        // --- Interaction Logic ---
        function processInteraction() {
            const h1 = state.hands[0];
            const h2 = state.hands[1];

            let desired = 'IDLE';
            if (h1 && h2) {
                if (h1.gesture.isPinch && h2.gesture.isPinch) desired = 'SCALING';
                else if (h1.gesture.isClosed && h2.gesture.isClosed) desired = 'TRANSLATING';
                else if (h1.gesture.isPinch && h2.gesture.isOpen) desired = 'ROTATING';
                else if (h2.gesture.isPinch && h1.gesture.isOpen) desired = 'ROTATING';
                else desired = 'IDLE';
            } else if (h1) {
                if (h1.gesture.isPinch) desired = 'ROTATING';
                else if (h1.gesture.isClosed) desired = 'TRANSLATING';
                else desired = 'IDLE';
            }

            if (desired === state.mode) {
                state.modeStability = 0;
            } else {
                state.modeStability++;
                if (state.modeStability > state.stabilityThreshold) {
                    state.mode = desired;
                    state.modeStability = 0;
                    initInteractionState(h1, h2);
                }
            }

            if (state.mode === 'SCALING' && h1 && h2) {
                const currentDist = getHandDistance(h1.gesture.center, h2.gesture.center);
                if (state.lastPinchDist > 0) {
                    const delta = currentDist - state.lastPinchDist;
                    let sensitivity = config.scaleUpSensitivity;
                    if (delta < 0) sensitivity = config.scaleDownSensitivity;
                    state.targetScale *= (1 + delta * sensitivity);
                    state.targetScale = clamp(state.targetScale, 0.05, 20); 
                }
                state.lastPinchDist = currentDist;
                ui.mode.innerText = "SCALING";
            } 
            else if (state.mode === 'TRANSLATING') {
                let master = h1;
                if (h1 && h2 && h1.gesture.isClosed && h2.gesture.isClosed) {
                    master = state.masterHandIndex === 0 ? h1 : h2;
                }
                if (master) {
                    const dx = (master.gesture.center.x - state.handStartPos.x) * 50;
                    const dy = -(master.gesture.center.y - state.handStartPos.y) * 50;
                    state.targetPosition.x = state.initialTrans.x + dx;
                    state.targetPosition.y = state.initialTrans.y + dy;
                }
                ui.mode.innerText = "TRANSLATING";
            } 
            else if (state.mode === 'ROTATING') {
                let active = h1;
                if (h1 && h2) active = h1.gesture.isPinch ? h1 : h2;
                if (active) {
                    const dx = (active.gesture.center.x - state.handStartPos.x) * 5;
                    const dy = (active.gesture.center.y - state.handStartPos.y) * 5;
                    state.targetRotation.y = state.initialRot.y + dx;
                    state.targetRotation.x = state.initialRot.x + dy;
                }
                ui.mode.innerText = "ROTATING";
            } 
            else {
                state.lastPinchDist = 0;
                ui.mode.innerText = "IDLE";
            }
        }

        function initInteractionState(h1, h2) {
            syncTargets();
            state.initialTrans.copy(modelGroup.position);
            state.initialRot.copy(modelGroup.rotation);

            if (state.mode === 'SCALING') {
                if (h1 && h2) {
                    state.lastPinchDist = getHandDistance(h1.gesture.center, h2.gesture.center);
                }
            } 
            else if (state.mode === 'ROTATING') {
                const active = h1 && h2 ? (h1.gesture.isPinch ? h1 : h2) : h1;
                if (active) {
                    state.handStartPos = { x: active.gesture.center.x, y: active.gesture.center.y };
                }
            } 
            else if (state.mode === 'TRANSLATING') {
                if (h1 && h2 && h1.gesture.isClosed && h2.gesture.isClosed) {
                    if (state.masterHandIndex === -1) state.masterHandIndex = 0;
                    const master = state.masterHandIndex === 0 ? h1 : h2;
                    state.handStartPos = { x: master.gesture.center.x, y: master.gesture.center.y };
                } else if (h1) {
                    state.handStartPos = { x: h1.gesture.center.x, y: h1.gesture.center.y };
                    state.masterHandIndex = -1;
                }
            }
        }

        function updateHandUI(h1, h2) {
            ui.handFeedback.style.opacity = (h1 || h2) ? 1 : 0;
            if (h1) {
                let status = "OPEN";
                if (h1.gesture.isPinch) status = "PINCH";
                else if (h1.gesture.isClosed) status = "CLOSED";
                ui.h1Status.innerText = `${h1.label}: ${status}`;
                ui.h1Status.style.opacity = 1;
            } else { ui.h1Status.style.opacity = 0.1; }
            
            if (h2) {
                let status = "OPEN";
                if (h2.gesture.isPinch) status = "PINCH";
                else if (h2.gesture.isClosed) status = "CLOSED";
                ui.h2Status.innerText = `${h2.label}: ${status}`;
                ui.h2Status.style.opacity = 1;
            } else { ui.h2Status.style.opacity = 0.1; }
        }

        // --- Animation Loop ---
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            const delta = (time - lastTime) / 1000;
            lastTime = time;

            if (delta > 0) {
                const fps = Math.round(1 / delta);
                if (Math.random() > 0.9) ui.fps.innerText = fps;
            }

            modelGroup.position.lerp(state.targetPosition, config.lerpFactor);
            modelGroup.rotation.x = lerp(modelGroup.rotation.x, state.targetRotation.x, config.rotationLerp);
            modelGroup.rotation.y = lerp(modelGroup.rotation.y, state.targetRotation.y, config.rotationLerp);
            
            const scaleVal = lerp(modelGroup.scale.x, state.targetScale, config.scaleLerp);
            modelGroup.scale.set(scaleVal, scaleVal, scaleVal);

            // Idle Animation Logic
            // Only orbit if: Mode is IDLE, Holo-Hand is OFF, AND Idle Orbit Toggle is ON
            if (state.mode === 'IDLE' && !config.holoEnabled && config.idleOrbitEnabled) {
                modelGroup.rotation.y += 0.002;
                modelGroup.position.y = 5 + Math.sin(time * 0.001) * 0.2;
                state.targetPosition.y = modelGroup.position.y;
                state.targetRotation.y = modelGroup.rotation.y;
            }

            if (holoMesh && Math.random() > 0.92) {
                const base = 0.6;
                holoMesh.material.opacity = base + (Math.random() * 0.2 - 0.1);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = () => {
            setTimeout(() => {
                ui.loader.style.opacity = 0;
                setTimeout(() => { ui.loader.style.display = 'none'; }, 800);
                animate(0);
            }, 1500);
        };

    </script>
</body>
</html>